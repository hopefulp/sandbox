.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFT32 3"
.TH FFT32 3 "2005-09-03" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Math::FFT \- Perl module to calculate Fast Fourier Transforms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  use Math::FFT;
\&  my $PI = 3.1415926539;
\&  my $N = 64;
\&  my ($series, $other_series);
\&  for (my $k=0; $k<$N; $k++) {
\&      $series->[$k] = sin(4*$k*$PI/$N) + cos(6*$k*$PI/$N);
\&  }
\&  my $fft = new Math::FFT($series);
\&  my $coeff = $fft->rdft();
\&  my $spectrum = $fft->spctrm;
\&  my $original_data = $fft->invrdft($coeff);
.Ve
.PP
.Vb 6
\&  for (my $k=0; $k<$N; $k++) {
\&      $other_series->[$k] = sin(16*$k*$PI/$N) + cos(8*$k*$PI/$N);
\&  }
\&  my $other_fft = $fft->clone($other_series);
\&  my $other_coeff = $other_fft->rdft();
\&  my $correlation = $fft->correl($other_fft);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements some algorithms for calculating
Fast Fourier Transforms for one-dimensional data sets of size 2^n.
The data, assumed to arise from a constant sampling rate, is
represented by an array reference \f(CW$data\fR (as described in the
methods below), which is then used to create a \f(CW\*(C`Math::FFT\*(C'\fR object as
.PP
.Vb 1
\&  my $fft = new Math::FFT($data);
.Ve
.PP
The methods available include the following.
.Sh "\s-1FFT\s0 \s-1METHODS\s0"
.IX Subsection "FFT METHODS"
.ie n .IP """$coeff = $fft\->cdft();""" 4
.el .IP "\f(CW$coeff = $fft\->cdft();\fR" 4
.IX Item "$coeff = $fft->cdft();"
This calculates the complex discrete Fourier transform
for a data set \f(CW\*(C`x[j]\*(C'\fR. Here, \f(CW$data\fR is a reference to an 
array \f(CW\*(C`data[0...2*n\-1]\*(C'\fR holding the data
.Sp
.Vb 2
\&  data[2*j] = Re(x[j]),
\&  data[2*j+1] = Im(x[j]), 0<=j<n
.Ve
.Sp
An array reference \f(CW$coeff\fR is returned consisting of
.Sp
.Vb 2
\&  coeff[2*k] = Re(X[k]),
\&  coeff[2*k+1] = Im(X[k]), 0<=k<n
.Ve
.Sp
where
.Sp
.Vb 1
\&   X[k] = sum_j=0^n-1 x[j]*exp(2*pi*i*j*k/n), 0<=k<n
.Ve
.ie n .IP """$orig_data = $fft\->invcdft([$coeff]);""" 4
.el .IP "\f(CW$orig_data = $fft\->invcdft([$coeff]);\fR" 4
.IX Item "$orig_data = $fft->invcdft([$coeff]);"
Calculates the inverse complex discrete Fourier transform
on a data set \f(CW\*(C`x[j]\*(C'\fR. If \f(CW$coeff\fR is not given, it will be set 
equal to an earlier call to \f(CW\*(C`$fft\->cdft()\*(C'\fR. \f(CW$coeff\fR is 
a reference to an array \f(CW\*(C`coeff[0...2*n\-1]\*(C'\fR holding the data
.Sp
.Vb 2
\&  coeff[2*j] = Re(x[j]),
\&  coeff[2*j+1] = Im(x[j]), 0<=j<n
.Ve
.Sp
An array reference \f(CW$orig_data\fR is returned consisting of
.Sp
.Vb 2
\&  orig_data[2*k] = Re(X[k]),
\&  orig_data[2*k+1] = Im(X[k]), 0<=k<n
.Ve
.Sp
where, excluding the scale,
.Sp
.Vb 1
\&   X[k] = sum_j=0^n-1 x[j]*exp(-2*pi*i*j*k/n), 0<=k<n
.Ve
.Sp
A scaling \f(CW\*(C`$orig_data\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.ie n .IP """$coeff = $fft\->rdft();""" 4
.el .IP "\f(CW$coeff = $fft\->rdft();\fR" 4
.IX Item "$coeff = $fft->rdft();"
This calculates the real discrete Fourier transform
for a data set \f(CW\*(C`x[j]\*(C'\fR. On input, \f(CW$data\fR is a reference to an
array \f(CW\*(C`data[0...n\-1]\*(C'\fR holding the data. An array reference
\&\f(CW$coeff\fR is returned consisting of
.Sp
.Vb 3
\&  coeff[2*k] = R[k], 0<=k<n/2
\&  coeff[2*k+1] = I[k], 0<k<n/2
\&  coeff[1] = R[n/2]
.Ve
.Sp
where
.Sp
.Vb 2
\&  R[k] = sum_j=0^n-1 data[j]*cos(2*pi*j*k/n), 0<=k<=n/2
\&  I[k] = sum_j=0^n-1 data[j]*sin(2*pi*j*k/n), 0<k<n/2
.Ve
.ie n .IP """$orig_data = $fft\->invrdft([$coeff]);""" 4
.el .IP "\f(CW$orig_data = $fft\->invrdft([$coeff]);\fR" 4
.IX Item "$orig_data = $fft->invrdft([$coeff]);"
Calculates the inverse real discrete Fourier transform
on a data set \f(CW\*(C`coeff[j]\*(C'\fR. If \f(CW$coeff\fR is not given, it will be set 
equal to an earlier call to \f(CW\*(C`$fft\->rdft()\*(C'\fR. \f(CW$coeff\fR 
is a reference to an array \f(CW\*(C`coeff[0...n\-1]\*(C'\fR holding the data
.Sp
.Vb 3
\&  coeff[2*j] = R[j], 0<=j<n/2
\&  coeff[2*j+1] = I[j], 0<j<n/2
\&  coeff[1] = R[n/2]
.Ve
.Sp
An array reference \f(CW$orig_data\fR is returned where, excluding the scale,
.Sp
.Vb 3
\&  orig_data[k] = (R[0] + R[n/2]*cos(pi*k))/2 + 
\&    sum_j=1^n/2-1 R[j]*cos(2*pi*j*k/n) + 
\&      sum_j=1^n/2-1 I[j]*sin(2*pi*j*k/n), 0<=k<n
.Ve
.Sp
A scaling \f(CW\*(C`$orig_data\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.ie n .IP """$coeff = $fft\->ddct();""" 4
.el .IP "\f(CW$coeff = $fft\->ddct();\fR" 4
.IX Item "$coeff = $fft->ddct();"
Computes the discrete cosine tranform on a data set
\&\f(CW\*(C`data[0...n\-1]\*(C'\fR contained in an array reference \f(CW$data\fR. An
array reference \f(CW$coeff\fR is returned consisting of
.Sp
.Vb 1
\&  coeff[k] = C[k], 0<=k<n
.Ve
.Sp
where
.Sp
.Vb 1
\&  C[k] = sum_j=0^n-1 data[j]*cos(pi*(j+1/2)*k/n), 0<=k<n
.Ve
.ie n .IP """$orig_data = $fft\->invddct([$coeff]);""" 4
.el .IP "\f(CW$orig_data = $fft\->invddct([$coeff]);\fR" 4
.IX Item "$orig_data = $fft->invddct([$coeff]);"
Computes the inverse discrete cosine tranform on a data set
\&\f(CW\*(C`coeff[0...n\-1]\*(C'\fR contained in an array reference \f(CW$coeff\fR. 
If \f(CW$coeff\fR is not given, it will be set equal to an earlier 
call to \f(CW\*(C`$fft\->ddct()\*(C'\fR. An array reference \f(CW$orig_data\fR 
is returned consisting of
.Sp
.Vb 1
\&  orig_data[k] = C[k], 0<=k<n
.Ve
.Sp
where, excluding the scale,
.Sp
.Vb 1
\&  C[k] = sum_j=0^n-1 coeff[j]*cos(pi*j*(k+1/2)/n), 0<=k<n
.Ve
.Sp
A scaling \f(CW\*(C`$orig_data\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.ie n .IP """$coeff = $fft\->ddst();""" 4
.el .IP "\f(CW$coeff = $fft\->ddst();\fR" 4
.IX Item "$coeff = $fft->ddst();"
Computes the discrete sine transform of a data set 
\&\f(CW\*(C`data[0...n\-1]\*(C'\fR contained in an array reference \f(CW$data\fR. An
array reference \f(CW$coeff\fR is returned consisting of
.Sp
.Vb 2
\& coeff[k] = S[k], 0<k<n
\& coeff[0] = S[n]
.Ve
.Sp
where
.Sp
.Vb 1
\& S[k] = sum_j=0^n-1 data[j]*sin(pi*(j+1/2)*k/n), 0<k<=n
.Ve
.ie n .IP """$orig_data = $fft\->invddst($coeff);""" 4
.el .IP "\f(CW$orig_data = $fft\->invddst($coeff);\fR" 4
.IX Item "$orig_data = $fft->invddst($coeff);"
Computes the inverse discrete sine transform of a data set 
\&\f(CW\*(C`coeff[0...n\-1]\*(C'\fR contained in an array reference \f(CW$coeff\fR, arranged as 
.Sp
.Vb 2
\& coeff[j] = A[j], 0<j<n
\& coeff[0] = A[n]
.Ve
.Sp
If \f(CW$coeff\fR is not given, it will be set equal to an earlier 
call to \f(CW\*(C`$fft\->ddst()\*(C'\fR. An array reference \f(CW$orig_data\fR 
is returned consisting of
.Sp
.Vb 1
\& orig_data[k] = S[k], 0<=k<n
.Ve
.Sp
where, excluding a scale,
.Sp
.Vb 1
\& S[k] =  sum_j=1^n A[j]*sin(pi*j*(k+1/2)/n), 0<=k<n
.Ve
.Sp
The scaling \f(CW\*(C`$a\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.ie n .IP """$coeff = $fft\->dfct();""" 4
.el .IP "\f(CW$coeff = $fft\->dfct();\fR" 4
.IX Item "$coeff = $fft->dfct();"
Computes the real symmetric discrete Fourier transform of a
data set \f(CW\*(C`data[0...n]\*(C'\fR contained in the array reference \f(CW$data\fR. An
array reference \f(CW$coeff\fR is returned consisting of 
.Sp
.Vb 1
\&  coeff[k] = C[k], 0<=k<=n
.Ve
.Sp
where
.Sp
.Vb 1
\&  C[k] = sum_j=0^n data[j]*cos(pi*j*k/n), 0<=k<=n
.Ve
.ie n .IP """$orig_data = $fft\->invdfct($coeff);""" 4
.el .IP "\f(CW$orig_data = $fft\->invdfct($coeff);\fR" 4
.IX Item "$orig_data = $fft->invdfct($coeff);"
Computes the inverse real symmetric discrete Fourier transform of a
data set \f(CW\*(C`coeff[0...n]\*(C'\fR contained in the array reference \f(CW$coeff\fR. 
If \f(CW$coeff\fR is not given, it will be set equal to an earlier 
call to \f(CW\*(C`$fft\->dfct()\*(C'\fR. An array reference \f(CW$orig_data\fR 
is returned consisting of
.Sp
.Vb 1
\&  orig_data[k] = C[k], 0<=k<=n
.Ve
.Sp
where, excluding the scale,
.Sp
.Vb 1
\&  C[k] = sum_j=0^n coeff[j]*cos(pi*j*k/n), 0<=k<=n
.Ve
.Sp
A scaling \f(CW\*(C`$coeff\->[0] *= 0.5\*(C'\fR, \f(CW\*(C`$coeff\->[$n] *= 0.5\*(C'\fR, and 
\&\f(CW\*(C`$orig_data\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.ie n .IP """$coeff = $fft\->dfst();""" 4
.el .IP "\f(CW$coeff = $fft\->dfst();\fR" 4
.IX Item "$coeff = $fft->dfst();"
Computes the real anti-symmetric discrete Fourier transform of a
data set \f(CW\*(C`data[0...n\-1]\*(C'\fR contained in the array reference \f(CW$data\fR. An
array reference \f(CW$coeff\fR is returned consisting of 
.Sp
.Vb 1
\&  coeff[k] = C[k], 0<k<n
.Ve
.Sp
where
.Sp
.Vb 1
\&  C[k] = sum_j=0^n data[j]*sin(pi*j*k/n), 0<k<n
.Ve
.Sp
(\f(CW\*(C`coeff[0]\*(C'\fR is used for a work area)
.ie n .IP """$orig_data = $fft\->invdfst($coeff);""" 4
.el .IP "\f(CW$orig_data = $fft\->invdfst($coeff);\fR" 4
.IX Item "$orig_data = $fft->invdfst($coeff);"
Computes the inverse real anti-symmetric discrete Fourier transform of a
data set \f(CW\*(C`coeff[0...n\-1]\*(C'\fR contained in the array reference \f(CW$coeff\fR.
If \f(CW$coeff\fR is not given, it will be set equal to an earlier 
call to \f(CW\*(C`$fft\->dfst()\*(C'\fR. An array reference \f(CW$orig_data\fR is 
returned consisting of
.Sp
.Vb 1
\&  orig_data[k] = C[k], 0<k<n
.Ve
.Sp
where, excluding the scale,
.Sp
.Vb 1
\&  C[k] = sum_j=0^n coeff[j]*sin(pi*j*k/n), 0<k<n
.Ve
.Sp
A scaling \f(CW\*(C`$orig_data\->[$i] *= 2.0/$n\*(C'\fR is then done so that
\&\f(CW$orig_data\fR coincides with the original \f(CW$data\fR.
.Sh "\s-1CLONING\s0"
.IX Subsection "CLONING"
The algorithm used in the transforms makes use of arrays for a work 
area and for a cos/sin lookup table dependent only on the size of 
the data set. These arrays are initialized when the \f(CW\*(C`Math::FFT\*(C'\fR object 
is created and then are populated when a transform method is first 
invoked. After this, they persist for the lifetime of the object.
.PP
This aspect is exploited in a \f(CW\*(C`cloning\*(C'\fR method; if a \f(CW\*(C`Math::FFT\*(C'\fR
object is created for a data set \f(CW$data1\fR of size \f(CW\*(C`N\*(C'\fR:
.PP
.Vb 1
\&  $fft1 = new Math::FFT($data1);
.Ve
.PP
then a new \f(CW\*(C`Math::FFT\*(C'\fR object can be created for a second data 
set \f(CW$data2\fR of the \fIsame\fR size \f(CW\*(C`N\*(C'\fR by
.PP
.Vb 1
\&   $fft2 = $fft1->clone($data2);
.Ve
.PP
The \f(CW$fft2\fR object will copy the reuseable work area and
lookup table calculated from \f(CW$fft1\fR.
.Sh "\s-1APPLICATIONS\s0"
.IX Subsection "APPLICATIONS"
This module includes some common applications \- correlation,
convolution and deconvolution, and power spectrum \- that
arise with real data sets. The conventions used here
follow that of \fINumerical Recipes in C\fR, by Press, Teukolsky,
Vetterling, and Flannery, in which further details of the
algorithms are given. Note in particular the treatment of end
effects by zero padding, which is assumed to be done by the
user, if required.
.IP "Correlation" 4
.IX Item "Correlation"
The correlation between two functions is defined as
.Sp
.Vb 3
\&             /
\&   Corr(t) = | ds g(s+t) h(s) 
\&             /
.Ve
.Sp
This may be calculated, for two array references \f(CW$data1\fR
and \f(CW$data2\fR of the same size \f(CW$n\fR, as either
.Sp
.Vb 3
\&   $fft1 = new Math::FFT($data1);
\&   $fft2 = new Math::FFT($data2);
\&   $corr = $fft1->correl($fft2);
.Ve
.Sp
or as
.Sp
.Vb 2
\&   $fft1 = new Math::FFT($data1);
\&   $corr = $fft1->correl($data2);
.Ve
.Sp
The array reference \f(CW$corr\fR is returned in wrap-around 
order \- correlations at increasingly positive lags are in 
\&\f(CW\*(C`$corr\->[0]\*(C'\fR (zero lag) on up to \f(CW\*(C`$corr\->[$n/2\-1]\*(C'\fR, 
while correlations at increasingly negative lags are in 
\&\f(CW\*(C`$corr\->[$n\-1]\*(C'\fR on down to \f(CW\*(C`$corr\->[$n/2]\*(C'\fR. The sign 
convention used is such that if \f(CW$data1\fR lags \f(CW$data2\fR (that 
is, is shifted to the right), then \f(CW$corr\fR will show a peak 
at positive lags.
.IP "Convolution" 4
.IX Item "Convolution"
The convolution of two functions is defined as
.Sp
.Vb 3
\&               /
\&   Convlv(t) = | ds g(s) h(t-s) 
\&               /
.Ve
.Sp
This is similar to calculating the correlation between the
two functions, but typically the functions here have a quite
different physical interpretation \- one is a signal which 
persists indefinitely in time, and the other is a response 
function of limited duration. The convolution may be calculated, 
for two array references \f(CW$data\fR and \f(CW$respn\fR, as
.Sp
.Vb 2
\&   $fft = new Math::FFT($data);
\&   $convlv = $fft->convlv($respn);
.Ve
.Sp
with the returned \f(CW$convlv\fR being an array reference. The method 
assumes that the response function \f(CW$respn\fR has an \fIodd\fR number 
of elements \f(CW$m\fR less than or equal to the number of elements \f(CW$n\fR 
of \f(CW$data\fR. \f(CW$respn\fR is assumed to be stored in wrap-around order \- 
the first half contains the response at positive times, while the 
second half, counting down from \f(CW\*(C`$respn\->[$m\-1]\*(C'\fR, contains the
response at negative times.
.IP "Deconvolution" 4
.IX Item "Deconvolution"
Deconvolution undoes the effects of convoluting a signal
with a known response function. In other words, in the relation
.Sp
.Vb 3
\&               /
\&   Convlv(t) = | ds g(s) h(t-s) 
\&               /
.Ve
.Sp
deconvolution reconstructs the original signal, given the convolution
and the response function. The method is implemented, for two array 
references \f(CW$data\fR and \f(CW$respn\fR, as
.Sp
.Vb 2
\&   $fft = new Math::FFT($data);
\&   $deconvlv = $fft->deconvlv($respn);
.Ve
.Sp
As a result, if the convolution of a data set \f(CW$data\fR with
a response function \f(CW$respn\fR is calculated as
.Sp
.Vb 2
\&   $fft1 = new Math::FFT($data);
\&   $convlv = $fft1->convlv($respn);
.Ve
.Sp
then the deconvolution
.Sp
.Vb 2
\&   $fft2 = new Math::FFT($convlv);
\&   $deconvlv = $fft2->deconvlv($respn);
.Ve
.Sp
will give an array reference \f(CW$deconvlv\fR containing the
same elements as the original data \f(CW$data\fR.
.IP "Power Spectrum" 4
.IX Item "Power Spectrum"
If the \s-1FFT\s0 of a real function of \f(CW\*(C`N\*(C'\fR elements is calculated, 
the \f(CW\*(C`N/2+1\*(C'\fR elements of the power spectrum are defined, in terms 
of the (complex) Fourier coefficients \f(CW\*(C`C[k]\*(C'\fR, as
.Sp
.Vb 3
\&   P[0] = |C[0]|^2 / N^2
\&   P[k] = 2 |C[k]|^2 / N^2   (k = 1, 2 ,..., N/2-1)
\&   P[N/2] = |C[N/2]|^2 / N^2
.Ve
.Sp
Often for these purposes the data is partitioned into \f(CW\*(C`K\*(C'\fR
segments, each containing \f(CW\*(C`2M\*(C'\fR elements. The power spectrum
for each segment is calculated, and the net power spectrum
is the average of all of these segmented spectra.
.Sp
Partitioning may be done in one of two ways: \fInon-overlapping\fR and
\&\fIoverlapping\fR. Non-overlapping is useful when the data set
is gathered in real time, where the number of data points
can be varied at will. Overlapping is useful where there is
a fixed number of data points. In non\-overlapping, the first
<2M> elements constitute segment 1, the next \f(CW\*(C`2M\*(C'\fR elements
are segment 2, and so on up to segment \f(CW\*(C`K\*(C'\fR, for a total of
\&\f(CW\*(C`2KM\*(C'\fR sampled points. In overlapping, the first and second
\&\f(CW\*(C`M\*(C'\fR elements are segment 1, the second and third \f(CW\*(C`M\*(C'\fR elements
are segment 2, and so on, for a total of \f(CW\*(C`(K+1)M\*(C'\fR sampled points.
.Sp
A problem that may arise in this procedure is \fIleakage\fR: the
power spectrum calculated for one bin contains contributions
from nearby bins. To lessen this effect \fIdata windowing\fR is
often used: multiply the original data \f(CW\*(C`d[j]\*(C'\fR by a window
function \f(CW\*(C`w[j]\*(C'\fR, where j = 0, 1, ..., N\-1. Some popular choices 
of such functions are
.Sp
.Vb 3
\&              | j - N/2 |
\&  w[j] = 1 -  | ------- |     ... Bartlett   
\&              |   N/2   |
.Ve
.Sp
.Vb 3
\&              / j - N/2 \e 2
\&  w[j] = 1 -  | ------- |     ... Welch  
\&              \e   N/2   /
.Ve
.Sp
.Vb 3
\&           1   /                    \e
\&  w[j] =  ---  |1 - cos(2 pi j / N) |     ... Hann  
\&           2   \e                    /
.Ve
.Sp
The \f(CW\*(C`spctrm\*(C'\fR method, used as
.Sp
.Vb 2
\&    $fft = Math::FFT->new($data);
\&    $spectrum = $fft->spctrm(%options);
.Ve
.Sp
returns an array reference \f(CW$spectrum\fR representing the power 
spectrum for a data set represented by an array reference \f(CW$data\fR.
The options available are
.RS 4
.ie n .IP """window => window_name""" 4
.el .IP "\f(CWwindow => window_name\fR" 4
.IX Item "window => window_name"
This specifies the window function; if not given, no such
function is used. Accepted values (see above) are \f(CW"bartlett"\fR, 
\&\f(CW"welch"\fR, \f(CW"hann"\fR, and \f(CW\*(C`\e&my_window\*(C'\fR, where \f(CW\*(C`my_window\*(C'\fR is a 
user specified subroutine which must be of the form, for example,
.Sp
.Vb 4
\&   sub my_window {
\&      my ($j, $n) = @_;
\&      return 1 - abs(2*($j-$n/2)/$n);
\&   }
.Ve
.Sp
which implements the Bartlett window.
.ie n .IP """overlap => 1""" 4
.el .IP "\f(CWoverlap => 1\fR" 4
.IX Item "overlap => 1"
This specifies whether overlapping should be done; if true (1),
overlapping will be used, whereas if false (0), or not
specified, no overlapping is used.
.ie n .IP """segments => n""" 4
.el .IP "\f(CWsegments => n\fR" 4
.IX Item "segments => n"
This specifies that the data will be partitioned into \f(CW\*(C`n\*(C'\fR
segments. If not specified, no segmentation will be done.
.ie n .IP """number => m""" 4
.el .IP "\f(CWnumber => m\fR" 4
.IX Item "number => m"
This specifies that \f(CW\*(C`2m\*(C'\fR data points will be used for 
each segment, and must be a power of 2. The power 
spectrum returned will consist of \f(CW\*(C`m+1\*(C'\fR elements.
.RE
.RS 4
.RE
.Sh "\s-1STATISTICAL\s0 \s-1FUNCTIONS\s0"
.IX Subsection "STATISTICAL FUNCTIONS"
For convenience, a number of common statistical functions are 
included for analyzing real data. After creating the object as
.PP
.Vb 1
\&  my $fft = new Math::FFT($data);
.Ve
.PP
for a data set represented by the array reference \f(CW$data\fR
of size \f(CW\*(C`N\*(C'\fR, these methods may be called as follows.
.ie n .IP """$mean = $fft\->mean([$data]);""" 4
.el .IP "\f(CW$mean = $fft\->mean([$data]);\fR" 4
.IX Item "$mean = $fft->mean([$data]);"
This returns the mean
.Sp
.Vb 1
\&  1/N * sum_j=0^N-1 data[j]
.Ve
.Sp
If an array reference \f(CW$data\fR is not given, the data set used 
in creating \f(CW$fft\fR will be used.
.ie n .IP """$stdev = $fft\->stdev([$data]);""" 4
.el .IP "\f(CW$stdev = $fft\->stdev([$data]);\fR" 4
.IX Item "$stdev = $fft->stdev([$data]);"
This returns the standard deviation
.Sp
.Vb 1
\&  sqrt{ 1/(N-1) * sum_j=0^N-1 (data[j] - mean)**2 }
.Ve
.Sp
If an array reference \f(CW$data\fR is not given, the data set used 
in creating \f(CW$fft\fR will be used.
.ie n .IP """$rms = $fft\->rms([$data]);""" 4
.el .IP "\f(CW$rms = $fft\->rms([$data]);\fR" 4
.IX Item "$rms = $fft->rms([$data]);"
This returns the root mean square
.Sp
.Vb 1
\&  sqrt{ 1/N * sum_j=0^N-1 (data[j])**2 }
.Ve
.Sp
If an array reference \f(CW$data\fR is not given, the data set used 
in creating \f(CW$fft\fR will be used.
.ie n .IP """($min, $max) = $fft\->range([$data]);""" 4
.el .IP "\f(CW($min, $max) = $fft\->range([$data]);\fR" 4
.IX Item "($min, $max) = $fft->range([$data]);"
This returns the minimum and maximum values of the data set.
If an array reference \f(CW$data\fR is not given, the data set used 
in creating \f(CW$fft\fR will be used.
.ie n .IP """$median = $fft\->median([$data]);""" 4
.el .IP "\f(CW$median = $fft\->median([$data]);\fR" 4
.IX Item "$median = $fft->median([$data]);"
This returns the median of a data set. The median is defined,
for the \fIsorted\fR data set, as either the middle element, if the
number of elements is odd, or as the interpolated value of
the the two values on either side of the middle, if the number
of elements is even. If an array reference \f(CW$data\fR is not given, 
the data set used in creating \f(CW$fft\fR will be used.
.SH "BUGS"
.IX Header "BUGS"
Please report any to Randy Kobes <randy@theoryx5.uwinnipeg.ca>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::Pari and \s-1PDL\s0
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The algorithm used in this module to calculate the Fourier
transforms is based on the C routine of fft4g.c available
at http://momonga.t.u\-tokyo.ac.jp/~ooura/fft.html, which is
copyrighted 1996\-99 by Takuya \s-1OOURA\s0. The file arrays.c included 
here to handle passing arrays to and from C comes from the \s-1PGPLOT\s0 
module of Karl Glazebrook <kgb@aaoepp.aao.gov.au>. The perl code 
of Math::FFT is copyright 2000,2005 by Randy Kobes <r.kobes@uwinnipeg.ca>,
and is distributed under the same terms as Perl itself.
